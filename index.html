<!DOCTYPE html>
<html prefix="og:http://ogp.me/ns#">
  <head>
    <title>2016.12.3</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="keywords" content="keywords,keywords,keywords">
    <meta name="description" content="description description description description">
    <meta property="og:title" content="2016.12.3">
    <meta property="og:description" content="description description description description">
    <meta property="og:url" content="http://sample.com/">
    <meta property="og:type" content="website">
    <meta property="og:image" content="http://sample.com/assets/img/ogp.png">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="2016.12.3">
    <meta name="twitter:description" content="description description description description">
    <meta name="twitter:image" content="http://sample.com/assets/img/ogp.png">
    <!--link rel="shortcut icon" href="/favicon.png">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png"-->
    <link rel="stylesheet" media="all" href="assets/css/common.css" type="text/css">
  </head>
  <body class="index">
    <div id="wrapper">
      <div id="loading"></div>
      <div id="contents">
        <section id="main">
          <canvas></canvas>
        </section>
      </div>
    </div>
    <script src="assets/js/lib/three.js" type="text/javascript"></script>
    <script src="assets/js/lib/TrackballControls.js" type="text/javascript"></script>
    <script src="assets/js/lib/TweenMax.js" type="text/javascript"></script>
    <script src="assets/js/lib/dat.gui.js" type="text/javascript"></script>
    <script src="assets/js/lib/jquery.js" type="text/javascript"></script>
    <script src="assets/js/lib/webfontloader.js" type="text/javascript"></script>
    <script src="assets/js/step5/FloatingCharsGeometry.js" type="text/javascript"></script>
    <script src="assets/js/step5/FloatingChars.js" type="text/javascript"></script>
    <script src="assets/js/step5/MainVisual.js" type="text/javascript"></script>
    <script src="assets/js/step5/index.js" type="text/javascript"></script>
    <script id="vertexShader" type="x-shader/x-vertex">
      // three.jsが予め定義してるuniform変数
      uniform mat4 modelMatrix;  // モデル変換行列
      uniform mat4 viewMatrix;  // ビュー変換行列
      uniform mat4 projectionMatrix;  // プロジェクション変換行列
      uniform vec3 cameraPosition;  // カメラの位置
      uniform mat4 modelViewMatrix;

      // 自分で定義したuniform変数
      uniform float time;  // 経過時間
      uniform float numVertices;  // 文字数 (正方形の数)
      uniform float numTextureGridRows;  // テクスチャの横方向の文字数
      uniform float numTextureGridCols;  // テクスチャの縦方向の文字数
      uniform float textureTxtLength;  // テクスチャに使っている文字の数
      uniform float animationValue1;  // アニメーション適用度1
      uniform float animationValue2;  // アニメーション適用度2
      uniform float animationValue3;  // アニメーション適用度3
      uniform float animationValue4;  // アニメーション適用度3
      uniform float animationValue5;  // アニメーション適用度3
      uniform float animationValue6;  // アニメーション適用度3
      uniform float animationValue7;  // アニメーション適用度3
      uniform float animationValue8;  // アニメーション適用度3

      // FloatingCharsGeometryで追加したattribute
      attribute vec3 position;  // 座標
      attribute vec3 randomValues;  // ランダム値
      attribute vec3 normal;
      attribute float ringVIndex;  // 何番目の文字(正方形に)属するか
      attribute float vIndex;

      // フラグメントシェーダに渡す値
      varying vec4 vColor;  // 文字色

      // 定数としてPIを定義
      const float PI = 3.1415926535897932384626433832795;

      // 3次元ベクトルを任意の軸で回転
      vec3 rotateVec3(vec3 p, float angle, vec3 axis){
        vec3 a = normalize(axis);
        float s = sin(angle);
        float c = cos(angle);
        float r = 1.0 - c;
        mat3 m = mat3(
          a.x * a.x * r + c,
          a.y * a.x * r + a.z * s,
          a.z * a.x * r - a.y * s,
          a.x * a.y * r - a.z * s,
          a.y * a.y * r + c,
          a.z * a.y * r + a.x * s,
          a.x * a.z * r + a.y * s,
          a.y * a.z * r - a.x * s,
          a.z * a.z * r + c
        );
        return m * p;
      }

      // 範囲を設定し直す
      float map(float value, float inputMin, float inputMax, float outputMin, float outputMax, bool clamp) {
        if(clamp == true) {
          if(value < inputMin) return outputMin;
          if(value > inputMax) return outputMax;
        }

        float p = (outputMax - outputMin) / (inputMax - inputMin);
        return ((value - inputMin) * p) + outputMin;
      }

      // hsvの値をrgbに変換
      vec3 hsv2rgb(vec3 c) {
        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
      }

      // 距離から透明度を計算
      float getAlpha(float distance) {
        float da = abs(distance - 400.0) / 500.0;
        return clamp(1.0 - da, 0.0, 1.0);
      }

      // time, scale, offsetを使って角度を返す
      // 範囲は -PI ~ PI
      float getRad(float scale, float offset) {
        return map(mod(time * scale + offset, PI * 2.0), 0.0, PI * 2.0, -PI, PI, true);
      }

      float exponentialInOut_6_4(float t) {
        return t == 0.0 || t == 1.0
          ? t
          : t < 0.5
            ? +0.5 * pow(2.0, (20.0 * t) - 10.0)
            : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;
      }

      vec3 mod289_5_5(vec3 x) {
        return x - floor(x * (1.0 / 289.0)) * 289.0;
      }
      
      vec2 mod289_5_5(vec2 x) {
        return x - floor(x * (1.0 / 289.0)) * 289.0;
      }

      vec3 permute_5_6(vec3 x) {
        return mod289_5_5(((x*34.0)+1.0)*x);
      }

      float snoise_5_7(vec2 v) {
        const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
                            0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
                          -0.577350269189626,  // -1.0 + 2.0 * C.x
                            0.024390243902439); // 1.0 / 41.0
        // First corner
        vec2 i  = floor(v + dot(v, C.yy) );
        vec2 x0 = v -   i + dot(i, C.xx);

        // Other corners
        vec2 i1;
        //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0
        //i1.y = 1.0 - i1.x;
        i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
        // x0 = x0 - 0.0 + 0.0 * C.xx ;
        // x1 = x0 - i1 + 1.0 * C.xx ;
        // x2 = x0 - 1.0 + 2.0 * C.xx ;
        vec4 x12 = x0.xyxy + C.xxzz;
        x12.xy -= i1;

        // Permutations
        i = mod289_5_5(i); // Avoid truncation effects in permutation
        vec3 p = permute_5_6( permute_5_6( i.y + vec3(0.0, i1.y, 1.0 ))
          + i.x + vec3(0.0, i1.x, 1.0 ));

        vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
        m = m*m ;
        m = m*m ;

        // Gradients: 41 points uniformly over a line, mapped onto a diamond.
        // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)

        vec3 x = 2.0 * fract(p * C.www) - 1.0;
        vec3 h = abs(x) - 0.5;
        vec3 ox = floor(x + 0.5);
        vec3 a0 = x - ox;

        // Normalise gradients implicitly by scaling m
        // Approximation of: m *= inversesqrt( a0*a0 + h*h );
        m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );

        // Compute final noise value at P
        vec3 g;
        g.x  = a0.x  * x0.x  + h.x  * x0.y;
        g.yz = a0.yz * x12.xz + h.yz * x12.yw;
        return 130.0 * dot(m, g);
      }
      
      float getanimationValue(float animationValue, float randomValue) {
        float p = clamp(-map(randomValue, -1.0, 1.0, 0.0, 0.6, true) + animationValue * 1.5, 0.0, 1.0);
        p = exponentialInOut_6_4(p);
        return p;
      }

      // main processing
      void main() {
        vec3 pos = position;
        float theta;
        vec3 n = normal;
        float rad1, rad2;

        // アニメーションの半径
        float radius = 30.0;

        //
        // animation1
        // ビルボード
        //
        float p = getanimationValue(animationValue1, randomValues.x);
        if(p > 0.0) {
          pos -= animationValue1 * position;
          theta = getRad(4.0, (randomValues.x + randomValues.y + randomValues.z) * 20.0);
          pos.z += animationValue1 * (radius + radius * map(sin(theta), -1.0, 1.0, 0.0, 1.0, true));
          theta = getRad(4.0, randomValues.x * 20.0);
          pos = rotateVec3(pos, animationValue1 * theta, vec3(0.0, 1.0, 0.0));
          theta = getRad(4.0, randomValues.y * 20.0);
          pos = rotateVec3(pos, animationValue1 * theta, vec3(1.0, 0.0, 0.0));
          theta = getRad(4.0, randomValues.z * 20.0);
          pos = rotateVec3(pos, animationValue1 * theta, vec3(0.0, 0.0, 1.0));
        }

        //
        // animation2 - cylinder
        // 8個のリング状
        //
        p = getanimationValue(animationValue2, randomValues.x);
        if(p > 0.0) {
          float numRings = 8.0;  // リングの個数
          float ringIndex = mod(ringVIndex, numRings);  // どのリングに属するか
          float numVerticesPerRing = numVertices / numRings;  // リングごとの文字数

          // 4段階にリングの位置を設定
          pos.y += animationValue2 * map(ringIndex, 0.0, numRings - 1.0, -2.0 * radius, 2.0 * radius, true);
          pos.z += animationValue2 * 1.5 * radius;  // まず手前にradius分移動

          // y軸を中心にリング状になるように文字を配置
          theta = getRad(10.0, PI * 2.0 / numVerticesPerRing * mod((ringVIndex - ringIndex) / numRings, numVerticesPerRing));
          pos = rotateVec3(pos, animationValue2 * theta, vec3(0.0, 1.0, 0.0));
        }

        //
        // animation3 -- sphere (small particles)
        // 球面上の移動
        //

        p = getanimationValue(animationValue3, randomValues.x);
        if(p > 0.0) {
          pos.z +=  radius;
          theta = getRad(6.0, randomValues.x * 10.0);
          pos = rotateVec3(pos, theta, vec3(0.0, 1.0, 0.0));
          theta = getRad(6.0, randomValues.y * 10.0);
          pos = rotateVec3(pos, theta, vec3(1.0, 0.0, 0.0));
          theta = getRad(6.0, randomValues.z * 10.0);
          pos = rotateVec3(pos, theta, vec3(0.0, 0.0, 1.0));
        }

        //
        // animation4 - vibrating shards
        // credit @ takumi hasegawa #4
        //

        p = getanimationValue(animationValue4, randomValues.x);
        if(p > 0.0) {
          float noise = 1.0; // snoise_5_7(pos.xy); // own addition, need to create noise attribute to use instead. see takumi vertex shader
          pos = pos - randomValues * p;
          if (true) { // (mod(vIndex, 3.0) > 0.0) { // make run smoother
            pos.z += (p * (8.0 * randomValues.z * sin(randomValues.z * 100.0))); // (p * initial size of the quill)
            pos = rotateVec3(pos, p * getRad(10.0, randomValues.x * 10.0), vec3(1.0, 0, 0));
            pos = rotateVec3(pos, p * getRad(10.0, randomValues.y * 10.0), vec3(0, 1.0, 0));
            pos += (p * sin(getRad(60.0, randomValues.z * 60.0)) * randomValues.z * 16.0 * normalize(pos)); // (p *  speed of size change * maximum height *)
          }
        }

        //
        // animation 5 - sphere (tangential particles)
        // credit @ takumi hasegawa #5
        // 

        p = getanimationValue(animationValue5, randomValues.x);
        if(p > 0.0) {
          pos.z *= radius / 2.0 ;
          pos = pos + (pos + normalize(pos) * 3.0) * p; // 3.0 makes everything bigger
          rad1 = getRad(10.0, randomValues.x * 10.0);
          rad2 = getRad(10.0, randomValues.y * 10.0); // rad relates to the speed of the rotation
          pos = rotateVec3(pos, p * rad1, vec3(1.0, 0, 0));
          pos = rotateVec3(pos, p * rad2, vec3(0, 1.0, 0));
          n = rotateVec3(n, p * rad1, vec3(1.0, 0, 0));
          n = rotateVec3(n, p * rad2, vec3(0, 1.0, 0));
          pos += (p * sin(getRad(10.0, randomValues.z * 10.0)) * 3.0 * normalize(pos)); // 30.0 makes everything bigger, first 10 increases speed of oscillation
        }

        //
        // animation 6 - cube within a cube within a cube (cube cubed)
        // credit @ takumi hasegawa #6
        //

        // animation6
        p = getanimationValue(animationValue6, randomValues.x);
        if(p > 0.0) {
          pos = pos - randomValues.x * p;
          rad1 = getRad(30.0, randomValues.x * 10.0);
          rad2 = getRad(30.0, randomValues.y * 10.0);
          pos = rotateVec3(pos, p * rad1, vec3(1.0, 0, 0));
          pos = rotateVec3(pos, p * rad2, vec3(0, 1.0, 0));
          float triangleIndex = floor(vIndex / 3.0);
          float cubeIndex = mod(mod(triangleIndex, 41.0), 3.0);
          float size = 8.0 + cubeIndex * 8.0;
          float t = mod(time * 10.0 + randomValues.z * 10.0, 4.0);
          pos.x += (map(t, 0.0, 1.0, -1.0, 1.0, true) * size * p - size * p);
          pos.y += (map(t, 1.0, 2.0, -1.0, 1.0, true) * size * p - size * p);
          pos.x -= map(t, 2.0, 3.0, -1.0, 1.0, true) * size * p;
          pos.y -= map(t, 3.0, 4.0, -1.0, 1.0, true) * size * p;
          pos.z -= size * p;
          pos = rotateVec3(pos, p * PI * mod(triangleIndex, 2.0), vec3(1.0, 0, 0));
          pos = rotateVec3(pos, p * PI / 2.0 * mod(triangleIndex, 3.0), vec3(0, 1.0, 0));
          pos = rotateVec3(pos, p * PI / 2.0 * mod(triangleIndex, 4.0), vec3(0, 0, 1.00));
          pos = rotateVec3(pos, p * time * 2.0 * (cubeIndex + 1.0), vec3(1.0, 0, 0));
          pos = rotateVec3(pos, p * time * 2.0 * (cubeIndex + 1.0), vec3(0, 1.0, 0));
        }

        //
        // animation 7 - spiral
        // credit @ takumi animation # 3
        //

        p = getanimationValue(animationValue7, randomValues.x);
        if(p > 0.0) {
          pos = pos - randomValues.x * p; // spiral creation
          rad1 = getRad(40.0, randomValues.x); 
          rad2 = getRad(40.0, randomValues.y);
          pos = rotateVec3(pos, p * rad1, vec3(1.0, 0, 0)); // rotation speed of the triangles 
          pos = rotateVec3(pos, p * rad2, vec3(0, 1.0, 0));
          n = rotateVec3(n, p * rad1, vec3(1.0, 0, 0)); // rotate normals
          n = rotateVec3(n, p * rad2, vec3(0, 1.0, 0));
          float radius = 200.0 * map(randomValues.y, -1.0, 1.0, -0.68, 0.7, true); //randomValues.y, -.25, 0.25, -.75, 1.0, false); 
          // (inward radius feed, outward radius feed, inward radius limit, outward radius limit)
          float anim2CircleRad = getRad(6.0, randomValues.x * 60.0);
          pos += vec3(
            p * radius * cos(anim2CircleRad),
            p * 8.0 * sin(getRad(4.0, randomValues.y) * 10.0), // (p * amplitutde * sin(getRad(speed of oscillation, randomValues.y) * number of waves))
            p * radius * sin(anim2CircleRad)
          );
          pos = rotateVec3(pos, p * getRad(4.0, 0.0), vec3(0.3, 1.0, sin(time)));
          n = rotateVec3(n, p * getRad(4.0, 0.0), vec3(0.3, 1.0, sin(time)));
        }


        //
        // animation 8
        // credit @ takumi hasegawa animation 2
        //

        p = exponentialInOut_6_4(animationValue8);
        if(p > 0.0) {
          rad1 = getRad(3.0, 0.0);
          rad2 = getRad(5.0, 0.0);
          pos = rotateVec3(pos, p * rad1, vec3(1.0, 0, 0));
          pos = rotateVec3(pos, p * rad2, vec3(0, 1.0, 0));
          n = rotateVec3(n, p * rad1, vec3(1.0, 0, 0));
          n = rotateVec3(n, p * rad2, vec3(0, 1.0, 0));
          pos += (p * sin(getRad(200.0, 200.0)) * 0.06 * normalize(pos));
        }


        //
        // 最終的な座標とフラグメントシェーダに渡す文字色を計算
        //

        // model conversion
        vec4  modelPos  =  modelMatrix  *  vec4 ( pos ,  1.0 ) ;
      
        // view transform
        vec4  modelViewPos  =  viewMatrix  *  modelPos ;
      
        // processing for billboard (animation1)
        modelViewPos += vec4(position, 0.0) * animationValue1;

        // Assign projection-transformed coordinates to gl_Position
        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);

        float len = length(pos);
        vColor = vec4(hsv2rgb(vec3(
          map(sin(getRad(2.0,  0.6 + len * (animationValue5 * 0.2 + animationValue6 * 0.2 * 0.4))), -1.0, 1.0, 0.0, 1.0, true),
          map(cos(getRad(3.0,  2.0 + len * (animationValue8 * 2.0 + animationValue7 * 3.0))), -1.0, 1.0, 0.3, 0.5, true),
          map(cos(getRad(1.0,  0.3)), -1.0, 1.0, 1.6, 2.0, true) + animationValue4 * 0.2
        )), 1.0);

        // light
        float diffuse  = clamp(dot(n, normalize(vec3(1.0, 1.0, 1.0))) , 0.5, 1.0);
        vColor *= vec4(vec3(diffuse), 1.0);
      }

    </script>
    <script id="fragmentShader" type="x-shader/x-fragment">
      precision mediump float;

      varying vec4 vColor;  // color

      // main processing
      void main(){
        gl_FragColor = vColor;
      }
    </script>
  </body>
</html>